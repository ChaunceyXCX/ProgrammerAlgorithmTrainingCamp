### 解题思路

本题思路其实比较好想了，如何可以让数组和最大呢？

贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。

局部最优可以推出全局最优。

那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。

那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。

虽然这道题目大家做的时候，可能都不会去想什么贪心算法，一鼓作气，就AC了。

我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！

那么本题的解题步骤为：

- 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

### 代码

* c

```c
int cmp(const void * a, const void * b)
{
    return *(int *) a - *(int *)b; 
}
int largestSumAfterKNegations(int *nums, int numsSize, int k) {
    int ans = 0;
    qsort(nums, numsSize, sizeof(int), cmp);//排序
    int min = INT_MAX;//取最小值，用于奇数
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] < 0 && k > 0) {//先将前面的负数转正
            ans += abs(nums[i]);
            k--;
        } else {
            ans += nums[i];
        }
        min = fmin(min, abs(nums[i]));
    }
    return (k & 1) == 0 ? ans : ans - 2 * min;//如果k为奇数
    //说明肯定还有一个正数要转为负数才行
}


```

