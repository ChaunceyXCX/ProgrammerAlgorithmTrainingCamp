## 139.单词拆分
### 回溯

### 记忆回溯
### 动态规划-完全背包
#### 思路
- 单词是物品字符串是背包，判断物品能否把字符串装满
- 因为这道题的特殊性 需要先遍历背包再遍历物品这样方便取字符串的子串；
- 递推公式拆分背包容量为两份如果第一份是装满的，那么第二份如果能在字典中查到那么背包就能装满
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        int size = s.length();
        boolean[] dp = new boolean[size + 1];
        // 后面的再前面的基础上判断而来所以如果dp[0] = false 后面都为false
        dp[0] = true;

        for (int j = 1; j <= size; j++) {
            for (int i = 0; i < j; i++) {
                // 将背包拆分为[0-i]  [i-j]两份
                String subStr = s.substring(i, j);
                if (set.contains(subStr) && dp[i]){
                    dp[j] = true;
                }
            }
        }
        return dp[size];

    }
}
```

# 多重背包理论基础
- 什么是多重背包
1. 01背包是每个物品只有一个
2. 完全背包是每个物品有无限个
3. 多重背包就是每个物品的数量不同

- 例题:
>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

例如：

背包最大重量为10。

物品为：

|重量|价值|数量|
|--|--|--|
|物品0|1|	15|	2|
|物品1|3|	20|	3|
|物品2|4|	30|	2|

问背包能背的物品最大价值是多少？

和如下情况有区别么？

|重量	|价值	|数量|
|--|--|--|
|物品0	|1	|15|1|
|物品0	|1	|15|1|
|物品1	|3	|20|1|
|物品1	|3	|20|1|
|物品1	|3	|20|1|
|物品2	|4	|30|1|
|物品2	|4	|30|1|

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。

### 展开之后就可以用01背包的模板解题了
### 另一种方法就是在零一背包的基础上加一层for循环遍历物品数量
```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
        // 打印一下dp数组
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
```

# 背包问题总结
- 五步曲
1. 确定dp数组下标以及定义
2. 确定递推公式
3. dp数组如何初始化
4. 遍历顺序
5. 举例推导dp数组

- 题目以及总结

1. 能否装满背包或则最多能够装多少 :dp[j] = max(dp[j],dp[j-nums[i]]+nums[i])
   2. 416.动态分割等和子集
   3. 1049.最后一块石头的重量Ⅱ 
4. 问背包装满有几种方法: dp[j] += dp[j-nums[i]]
   5. 494.目标和
   6. 518.零钱兑换Ⅱ
   7. 377.组合总和Ⅳ
   8. 70.爬楼梯(完全背包)
9. 问背包装满最大价值: dp[j] = max(dp[j],dp[j-weight[i]]+value[i])
   10. 474.一和零
11. 问装满背包所有物品的最小个数:dp[j] = min(dp[j],dp[j-coins[i]+1])
    12. 322.零钱兑换
    13. 279.完全平方数


- 遍历顺序
1. 完全背包的遍历顺序有些讲究:
   2. 先便利物品再遍历背包的话是组和问题
   3. 先便利背包再遍历物品的话就是排列问题
